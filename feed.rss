<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Coder 灰桑</title><description>Stay Foolish, Always Foolish</description><link>https://coder.linsyorozuya.com</link><language>en</language><lastBuildDate>Mon, 24 May 2021 00:00:11 +0800</lastBuildDate><pubDate>Mon, 24 May 2021 00:00:11 +0800</pubDate><ttl>250</ttl><atom:link href="https://coder.linsyorozuya.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/SwiftUI%20%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%20@State%20%E5%8F%98%E6%9B%B4</guid><title>SwiftUI 如何监听 @State 变更</title><description></description><link>https://coder.linsyorozuya.com/posts/SwiftUI%20%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%20@State%20%E5%8F%98%E6%9B%B4</link><pubDate>Sat, 8 May 2021 12:00:00 +0800</pubDate><content:encoded><![CDATA[<h3>尝试过的 3 种实现方式</h3><pre><code><span class="keyword">import</span> Combine

<span class="keyword">struct</span> ObserveStateChange: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span>(spacing: <span class="number">32</span>) {
            <span class="type">Solution1</span>().<span class="call">padding</span>().<span class="call">background</span>(<span class="type">Color</span>.<span class="property">red</span>)
            <span class="type">Solution2</span>().<span class="call">padding</span>().<span class="call">background</span>(<span class="type">Color</span>.<span class="property">yellow</span>)
            <span class="type">Solution3</span>().<span class="call">padding</span>().<span class="call">background</span>(<span class="type">Color</span>.<span class="property">green</span>)
        }
    }

    <span class="comment">/// 1</span>
    <span class="keyword">struct</span> Solution1: <span class="type">View</span> {
        <span class="keyword">@State var</span> location: <span class="type">String</span> = <span class="string">""</span>

        <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
            <span class="keyword">let</span> binding = <span class="type">Binding</span>&lt;<span class="type">String</span>&gt;(get: {
                <span class="keyword">self</span>.<span class="property">location</span>
            }, set: {
                <span class="keyword">self</span>.<span class="property">location</span> = $0
                <span class="comment">// do whatever you want here</span>
                <span class="call">print</span>(<span class="string">"Solution1</span> \($0)<span class="string">"</span>)
            })

            <span class="type">TextField</span>(<span class="string">"Search Location"</span>, text: binding)
        }
    }

    <span class="comment">/// 2</span>
    <span class="keyword">struct</span> Solution2: <span class="type">View</span> {
        <span class="keyword">@State var</span> location: <span class="type">String</span> = <span class="string">""</span>

        <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
            <span class="type">TextField</span>(<span class="string">"Search Location"</span>, text: $location)
                .<span class="call">onReceive</span>(<span class="type">Just</span>(location)) { <span class="call">print</span>(<span class="string">"Solution2</span> \($0)<span class="string">"</span>) }
        }
    }

    <span class="comment">/// 3</span>
    <span class="keyword">struct</span> Solution3: <span class="type">View</span> {
        <span class="keyword">@State var</span> location: <span class="type">String</span> = <span class="string">""</span>

        <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
            <span class="type">TextField</span>(<span class="string">"Search Location"</span>, text: $location.<span class="call">onChange</span> { <span class="call">print</span>(<span class="string">"Solution3</span> \($0)<span class="string">"</span>) })
        }
    }
}

<span class="keyword">extension</span> <span class="type">Binding</span> {
    <span class="keyword">func</span> onChange(<span class="keyword">_</span> handler: <span class="keyword">@escaping</span> (<span class="type">Value</span>) -&gt; <span class="type">Void</span>) -&gt; <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt; {
        <span class="type">Binding</span>(
            get: { <span class="keyword">self</span>.<span class="property">wrappedValue</span> },
            set: { newValue <span class="keyword">in
                self</span>.<span class="property">wrappedValue</span> = newValue
                <span class="call">handler</span>(newValue)
            }
        )
    }
}

</code></pre><p>1⃣️使用定义一个 Binding 属性，通过 get 和 set 来变更 @State。</p><p>2⃣️通过 onReceive 监听 Just Publisher 包装 State 促发的事件</p><p>3⃣️通过拓展 Binding 添加一个方法实现方法一的类似实现，包裹一层 Binding 来将变更回调出去。</p><p><strong>经过实践推荐使用3⃣️。</strong></p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> { <span class="comment">// 'some' = opaque return type</span>
        <span class="type">Text</span>(<span class="string">"I am a View"</span>) <span class="comment">// the View element</span>
        .<span class="call">bold</span>()           <span class="comment">// modifier applied to the View</span>
        .<span class="call">padding</span>()        <span class="comment">// another modifier</span>
    }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/SwiftUI%20%E5%BC%80%E5%8F%91%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A%E7%9A%84%20MAC%20%E5%B0%8F%E5%BA%94%E7%94%A8</guid><title>SwiftUI - 开发图片模糊的 MAC 小应用</title><description></description><link>https://coder.linsyorozuya.com/posts/SwiftUI%20%E5%BC%80%E5%8F%91%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A%E7%9A%84%20MAC%20%E5%B0%8F%E5%BA%94%E7%94%A8</link><pubDate>Sat, 23 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>看完喵神的 《 SwiftUI 与 编程思想》，尝试使用了书中类 Redux 的架构写了给图片添加模糊和修改饱和度的 MAC 上的小应用。文章记录一些其中的要点，文章部分引用了书中的段落来记录。</p></blockquote><h2>🌠成果</h2><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/Pics@master/uPic/2020-05-25%2000-30-47.2020-05-25%2000_34_42.gif" alt="演示.gif"/><p>应用功能很简单：</p><ol><li>可以拖动图片到应用中</li><li>调节模糊程度</li><li>调节饱和度</li><li>拖动图片到其他软件</li></ol><h2>架构</h2><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/Pics@master/uPic/截屏2020-05-25%20下午2.21.32.png" alt="图"/><h3>数据流动方式的特点</h3><ol><li>将 app 当作一个状态机，状态决定用户界面。</li><li>这些状态都保存在一个 Store 对象中。</li><li>View 不能直接操作 State，而只能通过发送 Action 的方式，间接改变存储在 Store 中的 State。</li><li>Reducer 接受原有的 State 和发送过来的 Action，生成新的 State 。并返回执行相关额外操作的副作用 Command。</li><li>Store 接受并执行副作用 Command （网络操作、文件操作等与状态变更无关的操作）来继而发送新的 Action 再次触发 Reducer 返回新的 State。</li><li>用新的 State 替换 Store 中原有的状态，并用新状态来驱动更新界面。</li><li>使用 Binding 来完成界面和状态的双向绑定。</li></ol><p>使用这种架构的优势将 View 中的状态操作完全解耦到了 Store 上去操作，所以对 State 的状态修改得以集中到了一个地方去处理。对项目的阅读和维护都有很好的帮助。避免了项目复杂之后散落各处的状态修改。</p><h3>相关解释</h3><h4><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/Pics@master/uPic/截屏2020-05-25%20下午2.09.29.png" alt="文件结构"/></h4><p><strong>Store</strong>: 主要持有了 State 属性和一个接受和处理 Action 的 Reduce 函数。</p><pre><code>  <span class="keyword">class</span> Store: <span class="type">ObservableObject</span> {

 		<span class="keyword">@Published var</span> appState = <span class="type">AppState</span>()

    <span class="keyword">static func</span> reduce(state: <span class="type">AppState</span>, action: <span class="type">AppAction</span>) -&gt; (<span class="type">AppState</span>, <span class="type">AppCommand</span>?) {
        <span class="keyword">var</span> appState = state
        <span class="keyword">var</span> appCommond: <span class="type">AppCommand</span>?
        
        <span class="keyword">switch</span> action {
        <span class="keyword">case</span> .<span class="dotAccess">action</span>(<span class="keyword">let</span> something):
 
        ....
        }
        
        <span class="keyword">return</span> (appState,appCommond)
    }
    
    <span class="keyword">func</span> dispatch(<span class="keyword">_</span> action: <span class="type">AppAction</span>) {
        <span class="preprocessing">#if DEBUG</span>
        <span class="call">print</span>(<span class="string">"Action:</span> \(action)<span class="string">"</span>)
        <span class="preprocessing">#endif</span>
        
        <span class="keyword">let</span> result = <span class="type">Store</span>.<span class="call">reduce</span>(state: appState, action: action)
        appState = result.<span class="number">0</span>
        <span class="keyword">if let</span> command = result.<span class="number">1</span>{
            <span class="preprocessing">#if DEBUG</span>
            <span class="call">print</span>(<span class="string">"AppCommand:</span>\(command)<span class="string">"</span>)
            <span class="preprocessing">#endif</span>
            
            command.<span class="call">execute</span>(in: <span class="keyword">self</span>)
        }
    }
}
</code></pre><p><strong>State</strong>: 存放相关状态的位置。</p><p><strong>Action</strong>：一个定义相关操作的枚举</p><pre><code><span class="keyword">enum</span> AppAction {
    <span class="keyword">case</span> .<span class="dotAccess">action</span>(something: <span class="type">String</span>)
    ...
}
</code></pre><p><strong>Command</strong>：执行相关副作用操作的地方</p><pre><code><span class="keyword">protocol</span> AppCommand {
    <span class="keyword">func</span> execute(in store: <span class="type">Store</span>)
}

<span class="keyword">struct</span> WriteUserAppCommand: <span class="type">AppCommand</span> {
    <span class="keyword">let</span> user: <span class="type">User</span>
    
    <span class="keyword">func</span> execute(in store: <span class="type">Store</span>) {
        <span class="keyword">try</span>? <span class="type">FileHelper</span>.<span class="call">writeJSON</span>(user, to: .<span class="dotAccess">documentDirectory</span>, fileName: <span class="string">"user.json"</span>)
    }
    
}
</code></pre><h2>三种改变 State 的途径</h2><p>更准确的应该是两种，Command 的方式最终也是通过 Action 来处理相关状态改变。</p><h3>通过 Action 来改变 State</h3><p>通过向 Store 发送并处理 Action 来直接修改或间接通过 Command 来修改相关状态。</p><h3>通过 Binding 双向绑定改变 State</h3><p>利用 SwiftUI 的双向绑定的特性，可以直接把 State 和 View 绑定起来。当 View 的状态改变直接修改了 Store 中的原始状态。</p><h3>通过 Command 副作用来改变 State</h3><blockquote><p>“Reducer 的唯一职责应该是计算新的 State，而发送请求和接收响应，显然和返回新的 State 没什么关系，它们属于设置状态这一操作的“副作用”。在我们的架构中我们使用 Command 来代表“在设置状态的同时需要触发一些其他操作”这个语境。Reducer 在返回新的 State 的同时，还返回一个代表需要进行何种副作用的 Command 值 (对应上一段中的第一个时间点)。Store 在接收到这个 Command 后，开始进行额外操作，并在操作完成后发送一个新的 Action。这个 Action 中带有异步操作所获取到的数据。它将再次触发 Reducer 并返回新的 State，继而完成异步操作结束时的 UI 更新 。”</p></blockquote><p>Store 在接收到 Command 后，开始进行额外操作，并在操作完成后发送一个新的 Action。Action 再次触发 Reducer 并返回新的 State，继而完成 UI 更新 。</p><h2>用绑定来更新的状态时通过 Publisher 来订阅并处理事件</h2><p>对于通过 Action 改变的状态，如果我们想要执行网络请求这样的副作用，可以通过同时返回合适的 Command 完成。但是对于通过绑定来更新的状态，由于不会经过 Store 的 reducer 来处理状态并返回 Command，我们缺少一种有效的手段来在它们改变时执行副作用。</p><p>在 SwiftUI 中可以使用 combine 来解决这个问题。最简单的方法是在属性前加上 @Published 来为相关属性创建 Publisher 。然后在合适的位置订阅相关事件来执行额外的操作。</p><h2>总结</h2><p>通过这个架构体验到了 SwiftUI 开发数据驱动页面更新的便利和优势，而且 SwiftUI 还能用来开发 Mac 端的应用。虽然目前 SwiftUI 还在开始不成熟的阶段，但是有理由相信以后 SwiftUI 统一苹果全平台的时候。期待下个月的 WWDC 的 SwiftUI。</p>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/%E5%9C%A8%20Playground%20%E4%B8%AD%E7%BC%96%E8%AF%91%20SwiftUI</guid><title>在 Playground 中编译 SwiftUI 的代码</title><description></description><link>https://coder.linsyorozuya.com/posts/%E5%9C%A8%20Playground%20%E4%B8%AD%E7%BC%96%E8%AF%91%20SwiftUI</link><pubDate>Thu, 14 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>记录下在 Playground 中编译 SwiftUI 的代码。</p></blockquote><pre><code><span class="keyword">import</span> SwiftUI
<span class="keyword">import</span> PlaygroundSupport

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">@State var</span> counter = <span class="number">0</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Button</span>(action: { <span class="keyword">self</span>.<span class="property">counter</span> += <span class="number">1</span> }, label: {
                <span class="type">Text</span>(<span class="string">"Tap me!"</span>)
                    .<span class="call">padding</span>()
                    .<span class="call">background</span>(<span class="type">Color</span>(.<span class="dotAccess">tertiarySystemFill</span>))
                    .<span class="call">cornerRadius</span>(<span class="number">5</span>)
            })
            <span class="keyword">if</span> counter &gt; <span class="number">0</span> {
                <span class="type">Text</span>(<span class="string">"You've tapped</span> \(counter) <span class="string">times"</span>)
            } <span class="keyword">else</span> {
                <span class="type">Text</span>(<span class="string">"You've not yet tapped"</span>)
            }
        }
    }
}

<span class="type">PlaygroundPage</span>.<span class="property">current</span>.<span class="call">setLiveView</span>(<span class="type">ContentView</span>())

</code></pre><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/Pics@master/uPic/截屏2020-05-14%20上午11.43.34.png" alt="截屏2020-05-14 上午11.43.34"/>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%87%E5%BF%98</guid><title>命令行备忘</title><description></description><link>https://coder.linsyorozuya.com/posts/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%87%E5%BF%98</link><pubDate>Sat, 1 Feb 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>用到一个记一个。</p></blockquote><h3>创建文件</h3><pre><code>创建 helloword.<span class="property">txt</span> 文件
touch helloword.<span class="property">txt</span>
</code></pre><h3>创建文件夹</h3><pre><code>创建 html 文件夹
mkdir html
</code></pre><h3>展示文件内容</h3><pre><code>展示 helloword.<span class="property">txt</span> 文件内容
cat helloword.<span class="property">txt</span>
</code></pre><h3>查看当前文件夹</h3><pre><code>pwd
</code></pre><h3>Finder 打开当前路径的文件夹</h3><pre><code><span class="keyword">open</span> .
</code></pre><h3>移动文件和文件夹</h3><pre><code>mv file_to_move destination_directory
mv directory_to_move destination_directory
</code></pre><h3>重命名文件</h3><pre><code>mv old_file_name new_file_name
</code></pre><h3>拷贝文件和文件夹</h3><pre><code>cp file_to_copy new_file_name

拷贝文件夹需要加 -r 参数
cp -r directory_to_copy new_directory_name
</code></pre><h3>删除文件和文件夹</h3><pre><code>rm file_name

删除文件夹需要加 -r 参数
rm -r directory_name
</code></pre><h3>利用上一个命令的最后一个参数</h3><pre><code>mkdir ~/<span class="type">Desktop</span>/html
cd !$ 执行此命令会自动生成命令 
cd ~/<span class="type">Desktop</span>/html
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/Git%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98</guid><title>Git 命令备忘</title><description></description><link>https://coder.linsyorozuya.com/posts/Git%20%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98</link><pubDate>Sun, 26 Jan 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>笔记用于回顾。</p></blockquote><h3>查看当前文件状态</h3><p>要查看哪些文件处于什么状态，可以用 <code>git status</code> 命令。</p><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 如果你使用 git status -s 命令或 git status --short 命令，你将得到一种更为紧凑的格式输出。</p><h3>查看提交历史</h3><p><code>git log</code> 会按提交时间列出所有的更新。</p><p><code>git log -p</code>用来显示每次提交的内容差异。</p><p><code>git log -p -2</code>用来显示每次提交的内容差异，-2 显示最近两次提交。</p><h3>创建新分支并切换</h3><p><code>git checkout -b newBranch</code> 创建一个新的叫 <code>newBranch</code> 的分支，并切换到该分支。</p><h3>创建嵌套目录</h3><p><code>mkdir -p a/b</code> 创建嵌套的文件夹 a 和 b。</p><h3>合并分支</h3><p><code>git merge</code> 在这个命令下，Git 会找到两个分支的共同祖先，将这三者进行一个三方合并。这种三方合并会产生一个新的提交，当前会指向这个新的提交。</p><p><code>git rebase</code> 则不采用三方合并，它会比较要「合并的分支」和「两个分支的共同祖先」这两个提交，将其中的修改提取成一个补丁。然后在「当前分支」的提交上应用这个补丁，从而生成一个新的「提交」。这种方式被叫做「rebase」，中文叫「变基」。</p><h3>解决 Merge 冲突</h3><p><code>git merge --abort</code> 可以恢复到 merge 之前的状态。</p><h3>查看到所有关联到当前仓库的远程仓库</h3><p>通过 <code>git remote</code> 命令，我们可以查看到所有关联到当前仓库的远程仓库。</p><p>通过 <code>git remote show</code> 命令，我们可以查看某一个远程仓库的详细信息。</p><h3>git stash</h3><p><code>git stash</code> 这个命令可以将你当前进行到一半的工作保存到一个暂存区域，然后将当前目录回滚到上一次提交。</p><p><code>git stash apply</code>把之前放到储藏区的最新的那个修改切回来。</p><p><code>git stash list</code>可以把所有放到储藏区的修改都列出来。</p><p><code>git stash --list</code> 查看<code>git stash</code>命令列表。</p>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/%E8%AE%A9%20Xcode%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%A5%BD%E7%9C%8B</guid><title>让 Xcode 的代码更好看</title><description>这几年随着不断更新 Xcode 变得更加强大和易用，当然也被越来越多的开发者吐槽它的又胖又慢。但即便大家都在吐槽，但 Xcode 仍然是大部分 iOS 开发者的首选 IDE。</description><link>https://coder.linsyorozuya.com/posts/%E8%AE%A9%20Xcode%20%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%A5%BD%E7%9C%8B</link><pubDate>Wed, 2 Oct 2019 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>最近看了一篇 Xcode 编辑器字体颜色优化的文章 <a href="https://medium.com/flawless-app-stories/one-stop-xcode-coziness-ee8dc9c1eb8b">One-Stop Xcode Coziness</a> ，感觉效果不错。在此记录记录。</p></blockquote><p>这几年随着不断更新 Xcode 变得更加强大和易用，当然也被越来越多的开发者吐槽它的又胖又慢。但即便大家都在吐槽，但 Xcode 仍然是大部分 iOS 开发者的首选 IDE。</p><p>作为一个天天低头不见抬头见的代码编辑器，代码的颜色和字体看起来舒不舒服和简洁明了是非常重要的。 Xcode 的主题就是解决这方面需求的功能。你可以自定义类名、函数名、常量等等类型的代码颜色，这样你可以轻松的区分代码的类型以便更好的调试。</p><p>但是 Xcode 自带的主题一部分没有对相应类型的颜色加以区分，比如我喜欢的主题是 Sunset 这种淡黄色的主题就没有很好的区分一些类型的颜色。之前重装 Xcode 后，我都是直接选择 Sunset 主题，然后字体改为 15 号大小。如下图：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/ca7c3baa126a6c2bad029815d839b519.png"/><h3>优化方案</h3><p>所谓的优化其实就是替换你觉得更好的字体和优化相关的代码类型颜色。当然除了这个还有上文说的我看的文章里提到的通过编程连字体优化 <strong>逻辑运算符</strong>。这个我还是第一次知道，孤陋寡闻了。下图字体为 Fira Code 效果如下：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/912e227bf9128aa1c741dd13b60e2dff.png"/><p>可以看到想 &gt;= 这种符号就变得很像我们手写的这种符号了。我觉的看起来非常直观，当然每个人感觉不一样。</p><p>当然也有有很多编程连字字体，从 <a href="https://github.com/tonsky/FiraCode">Fira Code</a>， <a href="https://github.com/i-tu/Hasklig">Hasklig</a> 等免费字体到 <a href="http://www.fsd.it/fonts/pragmatapro.htm">PragmataPro</a> 等付费字体。你可以在 <a href="https://github.com/ProgrammingFonts/ProgrammingFonts">ProgrammingFonts 上</a> 浏览这些字体，也可以调整所需的字体，我觉得 Fira Code 挺好看的就使用 Fira Code 了。</p><p>然后文章作者实现了一个代码颜色和连字字体的 Xcode 主题，<strong>Yolo-theme。</strong> 你可以在他的 GitHub 上查看 <a href="https://github.com/wendyliga/yolo-theme?source=post_page-----ee8dc9c1eb8b----------------------">Yolo-theme</a></p><h3>放置主题文件地址</h3><p>下载主题后将文件放入 <code>~/Library/Developer/Xcode/UserData/FontAndColorThemes</code>, 然后重启 Xcode 在设置里选择主题即可。</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/2b9e8f99475e45326fa0cbbcce57ac8d.png"/>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/%E8%AE%B0%E5%BD%95%E3%80%8C%E6%AD%8C%E8%AF%8D%E6%B4%BE%E3%80%8D</guid><title>记录「歌词派」</title><description>终于个人的第二款 App 完成了，但是它却无法上架 App Store。从自己的需求出发而产生的产品，它最终只能服务于自己了。至少它还有我，所有至少写个文章记录下它.</description><link>https://coder.linsyorozuya.com/posts/%E8%AE%B0%E5%BD%95%E3%80%8C%E6%AD%8C%E8%AF%8D%E6%B4%BE%E3%80%8D</link><pubDate>Mon, 12 Aug 2019 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>终于个人的第二款 App 完成了，但是它却无法上架 App Store。从自己的需求出发而产生的产品，它最终只能服务于自己了。至少它还有我，所有至少写个文章记录下它。</p></blockquote><h3>UI 截图</h3><p>这几张本来是「歌词派」的 App Store 上的截图。现在上不了 App Store 只能放这里看看咯。（这些应用截图是使用 <a href="https://storescreens.com/?ref=producthunt">Store Screens</a> 应用做的，简单易用十分推荐。）</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/5a3e7526e58c4f6ab5d48adbd063d2ae.jpeg"/><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/d018c017e636464a62f5535b87c2441f.JPG"/><h3>视频</h3><iframe src="https://coder.linsyorozuya.com//player.bilibili.com/player.html%3Faid=370800767&bvid=BV1UZ4y1p7ZM&cid=195646550&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3>为何而生</h3><p>因为我喜欢听歌和偶尔唱歌，但是我不爱记歌词。而且一般只记得住那些高潮部分的歌词。所以就想做一个搜索、收藏和分享歌词的一个应用。搜了 App Store 没找到符合这个功能的应用，所以就开始自己动手看看能不能做一个。都想好付费模式了。。（后来想想大家怎么都没做应该是审核过不了的关系吧 @。@）</p><h3>创造过程</h3><p>做自己的个人应用真的让我越来越体会到一个作为创造者的乐趣。「歌词派」总共的开发时间大概做了不到一个月吧。</p><p>歌曲数据方面调研了挺久，一些歌词服务基本都是需要付费的。大部分大家都是抓的国内各大音乐产品的数据。因为我主要使用到歌词，所以对比了几家应用，还是 QQ 音乐的歌曲比较全。虽然有些歌不能听，但是你可以搜出来这些歌。</p><p>技术上没有什么很复杂的难点，主要是第一次运用了 Cloudkit 来存取数据。基本了解了 Cloudkit 的开发，因为这个东西基本也只有个人开发者回去使用它。所以基本看文档和一些文章就够了。</p><p>大部分时间基本是花在设计页面和一些小动画的调整上了。个人觉得用的挺舒服的，可惜也只能我自己用了。</p><h3>为何不能上架</h3><p>本来以为没有播放音乐，只是展示歌词的话版权方面应该没问题吧。结果歌词也是有版权的，审核马上就被拒绝了。</p><h3>我还是很喜欢它</h3><p>虽然不能上架，但是我自己还可以用呗。后面看看要不要删减点功能开源吧。最后分享一张从「歌词派」生成的分享的歌词吧</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/Pics@master/uPic/IMG_2536.JPG" alt="憨人"/>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/iOS%20Widget%20-%20%E4%BE%BF%E5%AE%9C%E5%90%97%20%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95</guid><title>iOS Widget - 便宜吗 开发问题记录</title><description>很久很久以前…淘宝是有价格变化曲线的，利用曲线可以很大程度上防止商家的虚假促销。但是不知到出于什么原因后来取消了这个功能。</description><link>https://coder.linsyorozuya.com/posts/iOS%20Widget%20-%20%E4%BE%BF%E5%AE%9C%E5%90%97%20%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95</link><pubDate>Mon, 9 Jan 2017 12:00:00 +0800</pubDate><content:encoded><![CDATA[<img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/842e151742401545fcebcb4a9cf219ce.png"/><p>WHY ---</p><p>很久很久以前…</p><p>淘宝是有价格变化曲线的，利用曲线可以很大程度上防止商家的虚假促销。但是不知到出于什么原因后来取消了这个功能。</p><p>庆幸的是浏览器上目前还有几款插件来显示历史价格，不幸的是手机上并没有。</p><p>只发现一款叫 <code>比一比价</code> 的 app 提供了这个功能（没有开发 widget），而且能查询大部分电商商品的价格曲线。</p><p>虽然可以查询，但是这个 app 的搜索过程繁琐，要是想查询一个商品的价格，你需要四个步骤：</p><ul><li>复制商品的衔接</li><li>打开 app</li><li>黏贴 链接</li><li>点击搜索</li></ul><p>可是我喜欢那种 Pin 和 TodayMind 那种无需打开 app 只需下拉通知栏就能使用的的快捷方式 @。@，所以我想要的步骤是：</p><ul><li>复制商品链接</li><li>下拉通知栏</li></ul><p>所以来了兴趣想自己写个 widget, 也学习下了解下通知栏的开发~</p><p><strong>（开发使用的是 <code>比一比价</code> 手机端使用的查询接口。由于数据不全，也就没做显示价格曲线的功能了）</strong></p><p>这个 APP 叫<code>便宜吗</code>，顺便也瞎弄了个图标~</p><p>看使用效果：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/caa79fa6370afa3313335584b07d5dcf.gif"/><p>官方文档关于 Today Extention 的篇幅不大。基本的要用的方法都讲到，然后再看看其他人的文章就可以开始入手了。（可以参考文章底部引用的两个链接地址。）</p><p>便宜吗的功能实现上很简单，主要就三个步骤：</p><ol><li>获取系统剪贴板上的链接：</li><li>利用链接请求数据</li><li>将数据显示到控件上</li></ol><p>当然还有一些细节处理，比如保存上次搜索的历史记录、如果地址相同显示上次搜索的数据等等。</p><p>这里主要记录下开发中遇到的一些问题（基于 iOS 10）：</p><ul><li><strong>高度问题</strong>：iOS 10 后 widget 高度有两种模式：折叠和展开。 折叠模式的最小高度是 110，但也是这种模式下的最大高度。对的，不能更改 @。@。 展开模式有最大高度的限制，根据设备的不同最大高度也是不同。</li></ul><p>设置扩展模式需要添加以下代码：</p><pre><code>- (void)<span class="call">viewDidLoad</span> {
    [<span class="keyword">super</span> viewDidLoad];
    
    <span class="keyword">self</span>.<span class="property">extensionContext</span>.<span class="property">widgetLargestAvailableDisplayMode</span> = <span class="type">NCWidgetDisplayModeExpanded</span>;
}

#pragma mark - 切换展开和折叠的模式执行的方法
- (void)widgetActiveDisplayModeDidChange:(<span class="type">NCWidgetDisplayMode</span>)activeDisplayMode withMaximumSize:(<span class="type">CGSize</span>)<span class="call">maxSize</span>
{
    <span class="keyword">if</span> (activeDisplayMode == <span class="type">NCWidgetDisplayModeCompact</span>) {
        <span class="keyword">self</span>.<span class="property">preferredContentSize</span> = maxSize;
    }<span class="keyword">else</span>
    {
		  
        <span class="keyword">self</span>.<span class="property">preferredContentSize</span> = <span class="type">CGSizeMake</span>(maxSize.<span class="property">width</span>, <span class="number">300</span>);
    }
}
</code></pre><ul><li><strong>背景色问题</strong>：默认的 widget 本景色是一个有些毛玻璃效果的白色。你如果试图改变成其他颜色的话，目前我发现的一个问题是 widget 底部两个圆角，在下拉通知栏的时候都是直角，通知栏下拉完全后，会有个直角变成默认的圆角的突变。目前我的解决办法是添加圆角来处理（测试圆角为 15 ）。=。=</li></ul><pre><code>- (void)addCornerRadius:(<span class="type">CGSize</span>)<span class="call">radius</span>
{
    
    <span class="type">UIBezierPath</span> *maskPath = [<span class="type">UIBezierPath</span> bezierPathWithRoundedRect:<span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, _contentContainerView.<span class="property">bounds</span>.<span class="property">size</span>.<span class="property">width</span>,_contentContainerView.<span class="property">bounds</span>.<span class="property">size</span>.<span class="property">height</span>) byRoundingCorners:<span class="type">UIRectCornerBottomLeft</span> | <span class="type">UIRectCornerBottomRight</span> cornerRadii:radius];
    <span class="type">CAShapeLayer</span> *maskLayer = [[<span class="type">CAShapeLayer</span> alloc] <span class="keyword">init</span>];
    maskLayer.<span class="property">frame</span> = _contentContainerView.<span class="property">bounds</span>;
    maskLayer.<span class="property">path</span> = maskPath.<span class="type">CGPath</span>;
    _contentContainerView.<span class="property">layer</span>.<span class="property">mask</span> = maskLayer;
}

</code></pre><ul><li><strong>数据问题</strong>：如果你想在 widget 中，添加一个全局变量来保存临时数据是不可行的。每次下拉通知栏后，所有数据都会清空。相当于每次下拉通知栏，所有的 widget 的生命周期又重新开始。收起通知栏所有 widget 生命周期结束。所以如果要保存上次的变量，可以用 NSUserDefaults 的方法来保存。</li></ul><p>总结 --</p><p>widget 开发还是要看需求是否符合 widget 的使用场景。由于高度的限制，其实更能去思考开发的核心功能是什么。如何充分利用 110 的空间去做一些便捷实用的事情，也许才是开发 widget 开发真正思考的事情吧。</p><p><a href="https://github.com/linsyorozuya/IsRealCheap">代码地址 GitHub</a></p><h5>额~：</h5><p><code>之前询问过 manmanbuy.com 能否使用相关接口，被否定后我建议他们做个相似的插件查询价格。后来真的做了并且已上线叫 历史价格查询。有这方面需求的可以去下载这个软件。</code></p><p><strong>相关链接：</strong></p><ul><li><a href="http://www.jianshu.com/p/ca3e11d7686c">iOS 开发之 widget 实现</a></li><li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/Today.html#//apple_ref/doc/uid/TP40014214-CH11-SW1">App Extension Programming Guide: Today</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E9%80%82%E5%BA%94%E5%86%85%E5%AE%B9%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98</guid><title>iOS 自定义控件适应内容大小问题</title><description></description><link>https://coder.linsyorozuya.com/posts/iOS%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E9%80%82%E5%BA%94%E5%86%85%E5%AE%B9%E5%A4%A7%E5%B0%8F%E9%97%AE%E9%A2%98</link><pubDate>Tue, 8 Nov 2016 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>Why: 之前学习封装了下类似标签页的控件但是并不能根据内容大小来变化高度，看了别人的代码学习下自定义控件如何自适应内容大小。做个笔记。</p></blockquote><p><em>相关链接：</em></p><ul><li><a href="https://github.com/zekunyan/TTGTagCollectionView">Github 上功能较全的项目： TTGTagCollectionView</a></li></ul><p>对于自动布局，最大的魅力在于它能随着内容的大小变化自动根据你的约束适应变化控件的大小，来达到显示的效果。所以自定义控件应该具备自适应大小的能力，才能适应更多的场景。最常见的场景就是 cell 上添加控件的时候。</p><h1>How：</h1><p>为此看了下 <a href="https://github.com/zekunyan/TTGTagCollectionView">其他人开源项目： TTGTagCollectionView</a> 学习下代码。看到自适应部分关键的代码在于一下几句话：</p><pre><code>#pragma mark - <span class="type">Layout</span>

- (void)<span class="call">layoutSubviews</span> {
    [<span class="keyword">super</span> layoutSubviews];
    _collectionView.<span class="property">frame</span> = <span class="keyword">self</span>.<span class="property">bounds</span>;
    <span class="keyword">if</span> (!<span class="type">CGSizeEqualToSize</span>(<span class="keyword">self</span>.<span class="property">bounds</span>.<span class="property">size</span>, [<span class="keyword">self</span> intrinsicContentSize])) {
        [<span class="keyword">self</span> invalidateIntrinsicContentSize];
    }
}

- (<span class="type">CGSize</span>)<span class="call">intrinsicContentSize</span> {
    <span class="keyword">return</span> _layout.<span class="property">collectionViewContentSize</span>;
}

#pragma mark - <span class="type">Public</span> methods

- (void)<span class="call">reload</span> {
    [_collectionView reloadData];
    [<span class="keyword">self</span> invalidateIntrinsicContentSize];
}   
 
</code></pre><p>关键的两个方法是：</p><ul><li><code>invalidateIntrinsicContentSize </code> ：使视图原有的内容大小无效。手动调用这个方法后，会自动调用 <code>intrinsicContentSize</code> 方法。</li></ul><p>使视图的内在内容大小无效。 当您的自定义视图中的某些内容更改使其内在内容大小无效时，请调用此方法。 这允许基于约束的布局系统在其下一个布局遍中考虑新的内在内容大小。</p><ul><li><code>intrinsicContentSize</code> ：重新设置视图的内容大小。</li></ul><p>接收视图的自然大小，仅考虑视图本身的属性。 自定义视图通常具有他们显示的布局系统不知道的内容。 设置此属性允许自定义视图与布局系统通信其想要基于其内容的大小。 该内在大小必须与内容框架无关，因为例如，没有办法基于改变的高度动态地将改变的宽度传送到布局系统。</p><p>从文档上可以看出只要用这两个方法基本就可以完成自是以内容大小的功能。关键在于在什么时机调用这两个方法去更新视图内容的大小了。</p><h4>值得一提</h4><p>在 storybored 或者 xib 中设置视图约束的时候，如果要设定高度变化的话，记得勾选相应的约束 remove at build time 这个选项来保证高度是可以变化的：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/137b515a04215f1560b19264387a71d7.png" alt="Untitled Image"/><p>或者在下图这个 Instrinsic Size 的属性里设置为 Placeholder，暂时给予视图一个占位的内容大小， 来避免 Xcode报错：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/f00981195aaeb506950f09cd2232d7e1.png" alt="Untitled Image"/><h1>what</h1><p>然后，修改了自己学习封装的类似标签页的控件的代码。让其具有自适应内容的大小：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/8d9e24c78e88a38b8a7c192403256191.gif" alt="Untitled Image"/><p><a href="https://github.com/linsyorozuya/LHTagsViewDemo">Demo 项目地址</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://coder.linsyorozuya.com/posts/%E5%AE%9E%E7%8E%B0%20Smartisan%20OS%20%E4%B8%AD%E9%A6%96%E9%A1%B5%E7%9A%84%20PageControll%20%E6%95%88%E6%9E%9C</guid><title>实现 Smartisan OS 中首页的 PageControll 效果</title><description></description><link>https://coder.linsyorozuya.com/posts/%E5%AE%9E%E7%8E%B0%20Smartisan%20OS%20%E4%B8%AD%E9%A6%96%E9%A1%B5%E7%9A%84%20PageControll%20%E6%95%88%E6%9E%9C</link><pubDate>Sat, 2 Jan 2016 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>在看 <a href="http://kittenyang.com/pagecontrol/"><code>kittenyang:在iOS中实现Smartisan OS中首页的PageControll效果</code></a> 和 <a href="http://www.cnblogs.com/ludashi/p/4994520.html"><code>视错觉：从一个看似简单的自定义控件说起</code></a> 这两篇文章感觉可以更好的实现实现 Smartisan OS 中首页的 PageControl 效果。</p></blockquote><p>锤子的效果：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/4cb12df20f3aa413ff375ff8640f7a9f.gif"/><p>首先 kittenyang 实现的，当亮点划过两个暗点的中间是还是显示的</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/7c62c3c797cc897b929bd28edad5d2f9.gif"/><p>再看视错觉文章里的效果：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/e239797e62ada73cf93b3aa124fb9614.gif"/><p>最终实现的效果：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/6441c406e870d24f369ac1a0640b6249.gif"/><h5>实现原理</h5><p>首先从效果看锤子的亮点，像是从孔的下方移动。所以给人感觉是上面挖了一排孔，亮点在地道移动所以两个空中间的地方看不到移动的亮点。所以不能直接使用一个 view 移动来解决。</p><p>恰巧看到另一篇文章，想到也许可以试试。</p><p><strong>原理就是：使用 mask 隐藏和利用相对移动产生时差。</strong></p><p>实现步骤：</p><ol><li>在自定义的 <code>LHPageControlview</code> 上创建几个未选中状态颜色的圆 darkCircle。</li></ol><ol start="2"><li>在自定义的 <code>LHPageControlview</code> 上创建一个圆大小的但透明的<code>_hightLightView</code>，它的作用就是利用 <code>mask</code> 属性将它子视图中超出 <code>_hightLightView</code> 显示区域的其他高亮的几个圆藏起来。</li></ol><p>3.<code>_hightLightView</code> 上添加 <code>_topHidenHightLightCircles</code> 视图，然后在 <code>_topHidenHightLightCircles</code> 上面添加相应数量的选中状态的圆<code>lightCircle</code>，注意他们的位置相对于 <code>LHPageControlview</code> 上的 <code>darkCircle</code>要一一对应。</p><p>整个控件结构如下图：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/038b67a55ab229d521c1a9d16aaada81.png"/><p><strong>移动的时候，移动 <code>_hightLightView</code> 的同时 <code>_topHidenHightLightCircles</code> 往相反方向移动同样距离，这样在视觉上就好像 <code>_topHidenHightLightCircles</code> 是静止的，看上去只是 <code>_hightLightView</code> 在移动。</strong></p><p><strong>这样当 <code>_hightLightView</code> 移动到选中状态的圆 <code>lightCircle</code> 时，相应的未选中状态的 <code>darkCircle</code> 上就像有高亮的圆 <code>lightCircle</code> 移动过来遮住并显示。</strong></p><p>移动时如图：</p><img src="https://cdn.jsdelivr.net/gh/linsyorozuya/i-code-log@gh-pages/archives/assets/b292297161f63b1badaae340db59995b.png"/><p>移动的关键代码：</p><pre><code><span class="type">CGFloat</span> scale = distance - (int)distance;
<span class="keyword">if</span> (scale == <span class="number">0</span> &amp;&amp; distance&gt;=<span class="number">1</span>) {
    scale = <span class="number">1</span>;
}

<span class="type">CGFloat</span> moveDistance = distance*(kPageHeight+<span class="number">5</span>);

<span class="type">CGAffineTransform</span> transform = <span class="type">CGAffineTransformIdentity</span>;



transform = <span class="type">CGAffineTransformTranslate</span>(transform, moveDistance, <span class="number">0</span>);


<span class="keyword">if</span> (scale &gt;= <span class="number">0</span> &amp;&amp; scale &lt;= <span class="number">0.2</span>) {
    transform = <span class="type">CGAffineTransformScale</span>(transform, <span class="number">1.0</span>-scale, <span class="number">1.0</span>-scale);
}

<span class="keyword">if</span> (scale &gt; <span class="number">0.2</span> &amp;&amp; scale &lt; <span class="number">0.8</span>) {
    transform = <span class="type">CGAffineTransformScale</span>(transform, <span class="number">0.8</span>, <span class="number">0.8</span>);
}

<span class="keyword">if</span> (scale &gt; <span class="number">0.8</span> &amp;&amp; scale &lt;= <span class="number">1</span>) {
    transform = <span class="type">CGAffineTransformScale</span>(transform, scale, scale);
}


_hightLightView.<span class="property">layer</span>.<span class="property">affineTransform</span> = transform;




transform = <span class="type">CGAffineTransformIdentity</span>;

transform = <span class="type">CGAffineTransformTranslate</span>(transform, -moveDistance, <span class="number">0</span>);

_topHidenHightLightCircles.<span class="property">layer</span>.<span class="property">affineTransform</span> = transform;


</code></pre><p>这样就实现了基本效果。</p><p>~我在中间为了实现缩小效果，使用实时改变 _hightLightView layer 的 cornerRadius 大小。如果慢慢拖动会发现中间是有些问题的。(希望指教有什么好的方法 =。= 谢过)~</p><p>解决<br>还是得自己解决。=。=。最近看到 <code>CGAffineTransform</code> 这个类，可以直接根据自己的中心点来进行缩放和移动。省去了再去计算在父 view 的坐标去移动。</p><p>Github 代码：<a href="https://github.com/LinBling/LHPageControlTry"><code>传送门</code></a></p>]]></content:encoded></item></channel></rss>